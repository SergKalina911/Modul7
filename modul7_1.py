"""                                     Вступ

Привіт!

У цьому модулі ми продовжимо вивчати ООП у Python і познайомимось з новими конструкціями, 
характерними для нього.

Розглянемо такі теми:

 -Магічні методи класів, використання __str__ та __repr__ , _getitem__ та __setitem__
- Перевизначення математичних операторів + , - , / , // , % , *
- Перевизначення операторів порівняння <, <=, >, >=, ==, !=
- Управління атрибутами та методами в класах. Гетери та сетери
- Статичні та класові методи і їх використання всередині класів
- Функтори і магічний метод __**call__**
- Створення об'єкта ітератора та генератора
- Методи передачі значень у генератор
-Створення власних менеджерів контексту

В результаті проходження модуля, ти розшириш свій toolkit з обєктно-орієнтованого програмування у Python.


                                        7.1 Використання спеціальних методів для керування об'єктами
                                        
                        Магічні методи класів
                        
Як ми вже обговорювали, в мові програмування Python практично кожен елемент можна розглядати як об'єкт. Ця 
унікальна особливість Python робить його особливо гнучким і потужним інструментом у руках розробників. 
Об'єктно-орієнтоване програмування (ООП) у Python дозволяє модифікувати поведінку об'єктів, змінюючи їх поля 
з даними та/або методи. Це означає, що розробник має можливість не просто створювати дані структури, але й 
керувати їх поведінкою на найнижчому рівні.

Коли ми застосовуємо до об'єкта оператор, такий як + або -, насправді, ми викликаємо специфічний метод цього 
об'єкта. Такі методи визначають, як об'єкт повинен реагувати на використання певного оператора. Це правило 
стосується більшості операторів у Python, роблячи можливим дуже точне та гнучке управління поведінкою об'єктів.

Методи, що відповідають за визначену поведінку об'єктів при використанні операторів або інших синтаксичних 
конструкцій, називаються магічними методами. Хоча вони й отримали таку назву через свою здатність "за лаштунками" 
змінювати стандартну поведінку, насправді немає нічого магічного у тому, як вони працюють.

Магічні методи – це просто засоби, які мова програмування Python надає розробникам для реалізації операторного 
перевантаження та інших потужних механізмів.

Ось чому вираз a + b на низькому рівні трансформується в виклик a.__add__(b), перетворюючи стандартну операцію 
додавання на виклик методу, який може бути перевизначений за бажанням розробника. Така можливість дає велику волю 
у налаштуванні поведінки об'єктів, дозволяючи, наприклад, створювати складні числові типи або реалізовувати 
оператори для роботи з власними класами даних.

Детальний перелік "магічних" методів, їх призначення та приклади застосування можна знайти у спеціалізованих 
джерелах та документації по Python. Наприклад, за цим посиланням (https://minhhh.github.io/posts/a-guide-to-pythons-magic-methods), 
розміщено вичерпний матеріал, що описує ці методи з прикладами їх застосування, що є надзвичайно корисним ресурсом 
для глибшого розуміння та ефективного використання магічних методів у власних проєктах.

У рамках цього уроку ми детальніше розглянемо деякі з найбільш часто використовуваних магічних методів. Це допоможе 
нам зрозуміти, як за їх допомогою можна керувати основними операціями та поведінкою об'єктів у Python.

Важливо пам'ятати, що імена всіх магічних методів в Python дотримуються строгої номенклатури: вони складаються з літер 
нижнього регістру та символів підкреслення, починаючись і закінчуючись подвійним символом підкреслення (__). 
Ця конвенція не тільки сприяє єдності стилю кодування, але й робить магічні методи легко впізнаваними серед іншого коду.

Магічний метод, який ми найчастіше використовуємо, — це метод __init__. Як ми вже знаємо, метод відповідає за ініціалізацію 
об'єкта. Коли ви створюєте об'єкт класу, то спочатку створюється порожній об'єкт, який містить лише обов'язкові службові 
атрибути. Після того як об'єкт створено, автоматично викликається метод __init__, який ми можемо модифікувати під наші потреби."""

class Human:
    def __init__(self, name: str, age: int = 0):
        self.name = name
        self.age = age

    def say_hello(self) -> str:
        return f'Hello! I am {self.name}'

bill = Human('Bill')
print(bill.say_hello())
print(bill.age)

jill = Human('Jill', 20)
print(jill.say_hello())
print(jill.age)

# Виведення:
# Hello! I am Bill
# 0
# Hello! I am Jill
# 20

""" В цьому прикладі ми створили клас Human, у якому визначили метод __init__. У цьому методі ми додаємо об'єктам цього 
класу поля name та age. Зверніть увагу, що метод __init__ може приймати аргументи позиційні та/або іменні, як і будь-який 
інший метод. Коли ми створюємо об'єкт класу Human, ми повинні класу передати обов'язково хоча б один аргумент, оскільки 
метод __init__ повинен приймати обов'язково name.

Магічний метод __init__ не обов'язково повинен приймати аргументи та містити лише створення полів. Цей метод можна 
використовувати для реалізації будь-яких дій, які вам потрібні на етапі, коли об'єкт вже створений та його потрібно 
ініціалізувати.

Додамо перевірку віку, щоб встановити, чи є людина повнолітньою, і відповідне поле is_adult, а також використаємо 
метод __init__ для виклику іншого методу класу під час ініціалізації."""

class Human:
    def __init__(self, name: str, age: int = 0):
        self.name = name
        self.age = age
        # Виклик методу під час ініціалізації
        self.is_adult = self.__check_adulthood()  
        
        # Приклад логування
        print(f"Створено Human: {self.name}, Вік: {self.age}, Дорослий: {self.is_adult}")

    def say_hello(self) -> str:
        return f'Hello! I am {self.name}'

    def __check_adulthood(self) -> bool:
        return self.age >= 18

bill = Human('Bill')
print(bill.say_hello())
print(f"Вік: {bill.age}, Дорослий: {bill.is_adult}")

jill = Human('Jill', 20)
print(jill.say_hello())
print(f"Вік: {jill.age}, Дорослий: {jill.is_adult}")

# Виведення:
# Створено Human: Bill, Вік: 0, Дорослий: False
# Hello! I am Bill
# Вік: 0, Дорослий: False
# Створено Human: Jill, Вік: 20, Дорослий: True
# Hello! I am Jill
# Вік: 20, Дорослий: True

""" У цьому прикладі, коли створюється об'єкт класу Human, наш магічний метод __init__ виконує наступні дії. Він, як 
і було до цього, ініціалізує поля name та age. Але тепер він визначає, чи є особа дорослою, використовуючи метод 
check_adulthood, і зберігає результат в поле is_adult. Також ми додали рядок який виводить інформацію про створення 
об'єкта.

Отже метод __init__ може використовуватись не лише для простої ініціалізації полів, але й для виконання будь-яких 
інших додаткових операцій, необхідних для підготовки об'єкта до використання.                        


                        Методи __str__ та __repr__
                        
Магічні методи __str__ та __repr__ в Python відіграють ключову роль у представленні об'єктів у вигляді рядків. Знання 
та правильне використання цих методів дозволяє контролювати, як об'єкти вашого класу відображаються і використовуються, 
що є важливою частиною розробки Python програм.

Коли в інтерактивному режимі роботи з Python ми хочемо побачити вміст деякого об'єкту, ми просто пишемо його ім'я в 
консолі та інтерпретатор виводить рядком представлення цього об'єкта.

У консолі ми бачимо [1, 2] але ж ми не використовували функцію print, як це трапилось? За цей механізм внутрішнього 
читабельного представлення об'єктів відповідає магічний метод __repr__. Цей метод приймає лише один аргумент (звичайно це 
self) і повинен повертати рядок.

Метод __repr__ призначений для створення офіційного рядкового представлення об'єкта. Розробники використовують його для 
однозначного ідентифікування об'єкта або навіть для відтворення об'єкта в іншому місці коду. Таке представлення може бути 
надзвичайно корисним під час налагодження, оскільки воно дозволяє розробникам отримати точне уявлення про стан об'єкта.

Тому коли ми хочемо у випадках, коли застосунок повинен відобразити об'єкт, виводити якусь корисну інформацію, ми повинні 
модифікувати цей метод. Наприклад, клас точки на площині в Декартових координатах:"""

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f"Point(x={self.x}, y={self.y})"

point = Point(2, 3)
print(repr(point))  # Виводить: Point(x=2, y=3)

""" Виконайте цей код у консолі Python і ви побачите Point(x=2, y=3).

Але головне призначення __repr__ це створення офіційного рядкового представлення об'єкта, яке можна використати для 
відновлення об'єкта. Метод __repr__ має повертати рядок, який, ідеально, міг би бути використаний в коді для відтворення 
об'єкта з тими самими даними.

    ☝ Використання __repr__ дозволяє розробникам отримати детальне представлення об'єкта, яке може бути використане для 
       точного відтворення об'єкта або для налагодження програми, допомагаючи ідентифікувати та виправляти помилки.

Це означає, що ви можете використовувати вираз, повернутий методом __repr__, як Python команду для створення нового об'єкта, 
який буде мати ті самі характеристики, що й оригінальний об'єкт. Ця особливість особливо корисна для налагодження, де ви 
можете легко відтворити об'єкти на основі їхнього __repr__ представлення.

Розглянемо наступний приклад з нашим класом Point:"""
class Point:
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y

    def __repr__(self):
        return f"Point(x={self.x}, y={self.y})"

original_point = Point(2, 3)
print(repr(original_point))  

# Використання рядка, повернутого __repr__, для створення нового об'єкта
new_point = eval(repr(original_point))
print(new_point)

# Виведення:
# Point(x=2, y=3)
# Point(x=2, y=3)

""" Ми створили об'єкт original_point класу Point та використали __repr__ для отримання його представлення 
repr(original_point). Далі ми можемо використовувати це представлення для створення нового об'єкта з такими 
ж атрибутами. Для цього використовують функцію eval, яка і створює новий об'єкт new_point з рядкового представлення.

Функція eval() використовується для виконання рядкового виразу як коду. Вона приймає рядок і виконує його як вираз 
Python, повертаючи результат виконання цього виразу. Коли метод __repr__ класу повертає рядок, його можна передати 
до eval(). Ідея полягає в тому, щоб виклик eval() з результатом __repr__ створив новий об'єкт, ідентичний оригіналу.

    ☝ Важливо пам'ятати про обережне використання eval(), оскільки виконання коду, отриманого з ненадійних джерел, 
    може призвести до серйозних проблем з безпекою.

Дуже схожий на метод __repr__, який відповідає за те, як об'єкт конвертується в рядок — це метод __str__. Коли ви 
викликаєте функцію str та передаєте їй якийсь об'єкт, то насправді цей об'єкт викликається магічним методом __str__.

Метод __str__ призначений для повернення рядкового представлення об'єкта, яке має бути читабельним і зрозумілим для 
людини. Коли ви викликаєте функцію str() для об'єкта або друкуєте об'єкт за допомогою print(), Python автоматично 
використовує метод __str__ вашого класу. Це дає вам, як розробнику, можливість визначити, як об'єкт має бути 
представлений у зрозумілій формі.

Тому важливо визначити метод __str__ у ваших класах: щоб надати інтуїтивно зрозуміле та зручне для читання 
представлення ваших об'єктів."""
class Human:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age

    def __str__(self):
        return f"Human named {self.name} who is {self.age} years old"
    
    def __repr__(self):
        return f"Human({self.name}, {self.age})"

human = Human("Alice", 30)
print(human)

# Виведення:
# Human named Alice who is 30 years old

""" Наш метод __str__ призначений для повернення рядка, який є зрозумілим для кінцевого користувача. Якщо цей метод 
не визначено, Python використає метод __repr__ як запасний варіант для перетворення об'єкта в рядок.

В підсумку магічні методи __str__ та __repr__ є важливими інструментами в арсеналі Python розробника. Вони дозволяють 
не тільки краще контролювати, як об'єкти класу представлені, але й поліпшити досвід користувачів та спростити процес 
налагодження. Вивчення та використання цих методів забезпечить повне використання можливостей об'єктно-орієнтованого 
програмування в Python.


                        Методи __getitem__ та __setitem__
                        
                        
Квадратні дужки дозволяють нам звертатися до елементів послідовності за індексом або до елементів словника за ключем. 
Методи __getitem__ та __setitem__ в Python використовуються для налаштування доступу до елементів об'єкта за допомогою 
індексації або ключів, подібно до роботи зі списками чи словниками. Ці магічні методи дозволяють нашим класам імітувати 
контейнерні типи даних.

Метод __getitem__ визначає, як об'єкт класу повинен вести себе при доступі до його елементів за допомогою індексу або 
ключа. Він приймає ключ або індекс як аргумент і повинен повертати значення, асоційоване з цим ключем або індексом.

Метод __setitem__ визначає, як об'єкт повинен поводити себе при присвоєнні значення елементу за певним індексом або 
ключем. Він приймає два аргументи: ключ (або індекс) та значення, яке потрібно асоціювати з цим ключем.

Розглянемо клас SimpleDict, який імітує поведінку словника:"""
class SimpleDict:
    def __init__(self):
        self.__data = {}

    def __getitem__(self, key):
        return self.__data.get(key, "Key not found")

    def __setitem__(self, key, value):
        self.__data[key] = value

# Використання класу
simple_dict = SimpleDict()
simple_dict['name'] = 'Boris'
print(simple_dict['name'])  
print(simple_dict['age'])  

""" У прикладі, SimpleDict використовує внутрішній приватний словник __data для зберігання своїх елементів. Метод __getitem__ 
дозволяє отримати значення за ключем, а __setitem__ – встановити нове значення для ключа.

Виведення:
Boris
Key not found

Такий підхід робить клас більшгнучким і інтуїтивно зрозумілим для користувачів, які звикли працювати зі стандартними 
контейнерами Python. Використання __getitem__ та __setitem__ дозволяє об'єктам класу інтегруватися з функціями та 
конструкціями мови, призначеними для роботи з послідовностями або відображеннями, наприклад, циклами for, операторами in, 
функціями len(), і так далі.

Крім того, цей підхід підвищує гнучкість класу, дозволяючи додавати додаткову логіку перевірки або обробки при доступі до 
елементів або їх зміні. Наприклад, тепер можна легко імплементувати перевірку типів даних або логування без зміни 
зовнішнього інтерфейсу класу.

Уявімо, що нам потрібно створити структуру даних, яка схожа на список, але з обмеженням: елементи списку повинні 
завжди залишатися в певному діапазоні значень. Наприклад, ми працюємо над програмою для керування температурою в 
приміщенні, де значення температури повинні бути обмежені мінімальним та максимальним порогом.

Реалізація:"""

class BoundedList:
    def __init__(self, min_value: int, max_value: int):
        self.min_value = min_value
        self.max_value = max_value
        self.__data = []

    def __getitem__(self, index: int):
        return self.__data[index]

    def __setitem__(self, index: int, value: int):
        if not (self.min_value <= value <= self.max_value):
            raise ValueError(f"Value {value} must be between {self.min_value} and {self.max_value}")
        if index >= len(self.__data):
            # Додати новий елемент, якщо індекс виходить за межі
            self.__data.append(value)
        else:
            # Замінити існуючий елемент
            self.__data[index] = value

    def __repr__(self):
        return f"BoundedList({self.max_value}, {self.min_value})"

    def __str__(self):
        return str(self.__data)

if __name__ == '__main__':
    temperatures = BoundedList(18, 26)

    for i, el in enumerate([20, 22, 25, 27]):
        try:
            temperatures[i] = el
        except ValueError as e:
            print(e)

    print(temperatures)

# Виведення:
# Value 27 must be between 18 and 26
# [20, 22, 25]

""" Як бачимо спроба встановити значення поза дозволеним діапазоном призводить до виведення помилки 
"Value 27 must be between 18 and 26". Ми встановили температурні обмеження для значень, що зберігаються 
в структурі даних і що вони завжди відповідають певним критеріям. Ми просто не зможемо додати дані до 
нашого списку які не проходять обмеження.

Ми можемо об'єднати нашу реалізацію з можливостями класу UserList. Успадкувавшись від UserList, ми отримуємо 
всі можливості звичайного списку, але з можливістю модифікації поведінки за допомогою перевизначення методів 
або додавання нових.

Реалізація:"""

from collections import UserList

class BoundedList(UserList):
    def __init__(self, min_value: int, max_value: int, initial_list=None):
        super().__init__(initial_list if initial_list is not None else [])
        self.min_value = min_value
        self.max_value = max_value
        self.__validate_list()

    def __validate_list(self):
        for item in self.data:
            self.__validate_item(item)

    def __validate_item(self, item):
        if not (self.min_value <= item <= self.max_value):
            raise ValueError(f"Item {item} must be between {self.min_value} and {self.max_value}")

    def append(self, item):
        self.__validate_item(item)
        super().append(item)

    def insert(self, i, item):
        self.__validate_item(item)
        super().insert(i, item)

    def __setitem__(self, i, item):
        self.__validate_item(item)
        super().__setitem__(i, item)

    def __repr__(self):
        return f"BoundedList({self.max_value}, {self.min_value})"

    def __str__(self):
        return str(self.data)

if __name__ == '__main__':
    temperatures = BoundedList(18, 26, [19, 21, 22])
    print(temperatures)

    for el in [20, 22, 25, 27]:
        try:
            temperatures.append(el)
        except ValueError as e:
            print(e)

    print(temperatures)

# Виведення:
# [19, 21, 22]
# Item 27 must be between 18 and 26
# [19, 21, 22, 20, 22, 25]

""" Тепер клас BoundedList веде себе як список, але з додатковим обмеженням на значення елементів, що зберігаються 
в ньому. Використання UserList як базового класу спрощує реалізацію, оскільки нам не потрібно заново визначати багато 
методів, типових для списку; замість цього ми можемо зосередитися на логіці валідації даних.

Зверніть увагу, що ми не виконали реалізацію метода __getitem__. Бо коли ми успадкувались від UserList, ми отримали 
всю функціональність стандартного списку Python, але з можливістю перевизначення або додавання методів для 
налаштування поведінки. Таким чином, __getitem__ та інші методи доступу до елементів вже є частиною UserList, і 
вони працюватимуть як очікується, якщо тільки ми не вирішимо їх перевизначити для зміни поведінки.

Наприклад можна додати логування:

def __getitem__(self, index):
        # Додати спеціальну логіку тут, наприклад, логування або перевірку
        print(f"Accessing item at index {index}")
        # Викликати оригінальний метод __getitem__
        return super().__getitem__(index)  


                        Перевизначення математичних операторів
                        
Перевизначення математичних операторів в Python дозволяє класам змінювати стандартну поведінку арифметичних операцій. 
Це відомо як перевантаження операторів (https://uk.wikipedia.org/wiki/%D0%9F%D0%B5%D1%80%D0%B5%D0%B2%D0%B0%D0%BD%D1%82%D0%B0%D0%B6%D0%B5%D0%BD%D0%BD%D1%8F_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80%D1%96%D0%B2). 
Використовуючи спеціальні методи, ви можете визначити або перевизначити поведінку операторів, таких як +, -, *, /, 
і багатьох інших для об'єктів ваших класів.

Ось деякі з найпоширеніших спеціальних методів для перевизначення математичних операторів:
__add__(self, other) для оператора +
__sub__(self, other) для оператора -
__mul__(self, other) для оператора *
__truediv__(self, other) для оператора /
__floordiv__(self, other) для оператора цілочисельного ділення //
__mod__(self, other) для оператора залишку від ділення %
__pow__(self, other) для оператора * піднесення до степеня

Перевизначення математичних операторів може стати зручним інструментом. Наприклад, створимо клас словників, які 
підтримують операції додавання та віднімання:"""

from collections import UserDict

class MyDict(UserDict):
    def __add__(self, other):
        temp_dict = self.data.copy()
        temp_dict.update(other)
        return MyDict(temp_dict)

    def __sub__(self, other):
        temp_dict = self.data.copy()
        for key in other:
            if key in temp_dict:
                temp_dict.pop(key)
        return MyDict(temp_dict)

if __name__ == '__main__':
    d1 = MyDict({1: 'a', 2: 'b'})
    d2 = MyDict({3: 'c', 4: 'd'})

    d3 = d1 + d2
    print(d3)

    d4 = d3 - d2
    print(d4)
# Виведення:
# {1: 'a', 2: 'b', 3: 'c', 4: 'd'}
# {1: 'a', 2: 'b'}

""" Синтаксис простий і код досить виразний.

Метод __add__ визначає поведінку для оператора +. Він дозволяє об'єднувати два об'єкти класу MyDict, додаючи 
всі елементи з другого словника other до першого (self). Спочатку створюється копія внутрішнього словника self.data, 
щоб уникнути зміни оригінального словника. До тимчасового словника додаються всі елементи з другого словника. 
Якщо ключі вже існують, їх значення будуть оновлені на значення з other. Магічний метод повертає новий екземпляр 
MyDict, ініціалізований з об'єднаного словника.

Метод __sub__ визначає поведінку для оператора -. Він дозволяє видаляти ключі з першого словника self, які присутні 
в другому other. Аналогічно методу __add__, спочатку створюється копія внутрішнього словника temp_dict. Далі цикл 
for перебирає всі ключі в другому словнику other. Умова if key in temp_dict перевіряє, чи присутній ключ у словнику 
temp_dict. Якщо так то видаляємо ключ і його значення з тимчасового словника, якщо такий ключ існує. Повертаємо новий 
екземпляр MyDict, ініціалізований після видалення ключів.

Розглянемо ще один приклад та створимо клас ComplexNumber для представлення комплексних чисел, з перевизначенням 
деяких арифметичних операторів:"""
class ComplexNumber:
    def __init__(self, real, imag):
        self.real = real
        self.imag = imag

    def __add__(self, other):
        return ComplexNumber(self.real + other.real, self.imag + other.imag)

    def __sub__(self, other):
        return ComplexNumber(self.real - other.real, self.imag - other.imag)

    def __mul__(self, other):
        real_part = self.real * other.real - self.imag * other.imag
        imag_part = self.real * other.imag + self.imag * other.real
        return ComplexNumber(real_part, imag_part)

    def __str__(self):
        return f"{self.real} + {self.imag}i"

if __name__ == "__main__":
    num1 = ComplexNumber(1, 2)
    num2 = ComplexNumber(3, 4)
    print(f"Сума: {num1 + num2}")
    print(f"Різниця: {num1 - num2}")
    print(f"Добуток: {num1 * num2}")

# Виведення:
# Сума: 4 + 6i
# Різниця: -2 + -2i
# Добуток: -5 + 10i

""" Наш приклад показує, як можна перевизначити арифметичні оператори для реалізації додавання, віднімання та 
множення комплексних чисел. Використання спеціальних методів робить можливим використання звичних математичних 
операторів з об'єктами, створюючи читабельний і інтуїтивно зрозумілий інтерфейс.

Перевизначення математичних операторів надає значні можливості для створення виразних і потужних абстракцій, що 
здатні імітувати поведінку вбудованих типів Python або створювати нові способи взаємодії з об'єктами ваших класів. 
Для прикладу реалізуємо векторне множення, де результатом є скалярний добуток векторів."""

from collections import UserList

class MulArray(UserList):
    def __init__(self, *args):
        self.data = list(args)

    def __mul__(self, other):
        return self.__scalar_mul(other)
    
    def __rmul__(self, other):
        return self.__scalar_mul(other) 
    
    def __scalar_mul(self, other):
        result = 0
        for i in range(min(len(self.data), len(other))):
            result += self.data[i] * other[i]
        return result

if __name__ == '__main__':
    vec1 = MulArray(1, 2, 3)
    vec2 = MulArray(3, 4, 5)

    print(vec1 * vec2)
    print(vec1 * [1, 2, 3])
    print([1, 1, 1] * vec2)

# Виведення:
# 26
# 14
# 12"""

""" Магічний метод __mul__ визначає поведінку операції множення * між екземпляром MulArray і іншим об'єктом. 
Він виконує скалярний добуток між self.data і другим списком, обмежуючи множення мінімальною довжиною обох списків. 
Результатом є сума добутків відповідних елементів списків. Тут в нас з'явився новий магічний метод __rmul__ який 
визначає поведінку операції множення, коли екземпляр MulArray знаходиться справа від оператора множення. Це з
абезпечує комутативність операції множення, дозволяючи виконувати множення з обох боків. Він необхідний, щоб ми 
могли виконати операцію [1, 1, 1] * vec2, коли екземпляр MulArray знаходиться справа від оператора множення. 
Реалізація ідентична до __mul__, тому результат буде таким же.


                        Перевизначення операцій порівняння


Перевизначення операцій порівняння в Python дозволяє об'єктам ваших класів взаємодіяти з операторами порівняння 
(<, <=, >, >=, ==, !=), щоб вказати, як саме об'єкти повинні бути порівнювані між собою. Це досягається за допомогою 
реалізації спеціальних методів у вашому класі.

Тому операції порівняння, як і інші оператори, мають свої "магічні" методи:
__eq__(self, other) — визначає поведінку під час перевірки на відповідність (==).
__ne__(self, other) — визначає поведінку під час перевірки на невідповідність. !=.
__lt__(self, other) — визначає поведінку під час перевірки на менше <.
__gt__(self, other) — визначає поведінку під час перевірки на більше >.
__le__(self, other) — визначає поведінку під час перевірки на менше-дорівнює <=.
__ge__(self, other) — визначає поведінку під час перевірки на більше-дорівнює >=.

Якщо нам потрібно, щоб об'єкт був порівнянний, ми можемо реалізувати ці шість методів і тоді будь-яка перевірка на 
порівняння працюватиме.

Розглянемо клас Rectangle, який представляє прямокутник з двома властивостями: шириною width і висотою height. Ми 
хочемо порівнювати прямокутники на основі розміру їх площі."""
class Rectangle:
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height

    def __eq__(self, other):
        if not isinstance(other, Rectangle):
            return NotImplemented
        return self.area() == other.area()

    def __ne__(self, other):
        return not self.__eq__(other)

    def __lt__(self, other):
        if not isinstance(other, Rectangle):
            return NotImplemented
        return self.area() < other.area()

    def __le__(self, other):
        return self.__lt__(other) or self.__eq__(other)

    def __gt__(self, other):
        if not isinstance(other, Rectangle):
            return NotImplemented
        return self.area() > other.area()

    def __ge__(self, other):
        return self.__gt__(other) or self.__eq__(other)

if __name__ == "__main__":
    rect1 = Rectangle(5, 10)
    rect2 = Rectangle(3, 20)
    rect3 = Rectangle(5, 10)
    print(f"Площа прямокутників: {rect1.area()}, {rect2.area()}, {rect3.area()}")
    print(rect1 == rect3)  # True: площі рівні
    print(rect1 != rect2)  # True: площі не рівні
    print(rect1 < rect2)  # True: площа rect1  менша, ніж у rect2
    print(rect1 <= rect3)  # True: площі рівні, тому rect1 <= rect3
    print(rect1 > rect2)  # False: площа rect1 менша, ніж у rect2
    print(rect1 >= rect3)  # True: площі рівні, тому rect1 >= rect3

# Виведення:
# Площа прямокутників: 50, 60, 50
# True
# True
# True
# True
# False
# True

""" Кожен з методів порівняння спирається на площу прямокутника як критерій порівняння. Метод __eq__ перевіряє 
рівність площ, а методи __lt__ та __gt__ порівнюють, чи менша або більша площа одного прямокутника за площу іншого. 
Інші методи будуються на цих базових порівняннях, забезпечуючи повний набір операцій порівняння.

Використання NotImplemented в методах порівняння є прийнятою і рекомендованою практикою, коли ви стикаєтеся з ситуацією, 
де ваш метод не знає, як порівнювати об'єкт з іншим типом об'єкта. Коли метод порівняння повертає NotImplemented, Python 
розуміє, що поточний метод не може виконати порівняння і спробує знайти інший спосіб порівняння, наприклад, викликавши 
відповідний метод у другого об'єкта або вдаючись до інших механізмів порівняння. Якщо жоден метод не може порівняти 
об'єкти, тоді інтерпретатор викине виключення TypeError. Наприклад операція порівняння rect1 > 10 призведе до TypeError: 
'>' not supported between instances of 'Rectangle' and 'int' .

Реалізуємо клас Point, який представляє точку в двовимірному просторі з координатами x та y. Основна мета прикладу 
показати можливість порівнювати точки за їхніми координатами за допомогою стандартних операторів 
порівняння (==, !=, <, >, <=, >=)."""
class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __eq__(self, other):
        if not isinstance(other, Point):
            return NotImplemented
        return self.x == other.x and self.y == other.y

    def __ne__(self, other):
        return not self.__eq__(other)

    def __lt__(self, other):
        if not isinstance(other, Point):
            return NotImplemented
        return self.x < other.x and self.y < other.y

    def __gt__(self, other):
        if not isinstance(other, Point):
            return NotImplemented
        return self.x > other.x and self.y > other.y

    def __le__(self, other):
        if not isinstance(other, Point):
            return NotImplemented
        return self.x <= other.x and self.y <= other.y

    def __ge__(self, other):
        if not isinstance(other, Point):
            return NotImplemented
        return self.x >= other.x and self.y >= other.y

if __name__ == "__main__":
    print(Point(0, 0) == Point(0, 0))  # True
    print(Point(0, 0) != Point(0, 0))  # False
    print(Point(0, 0) < Point(1, 0))  # False
    print(Point(0, 0) > Point(0, 1))  # False
    print(Point(0, 2) >= Point(0, 1))  # True
    print(Point(0, 0) <= Point(0, 0))  # True

""" Наш приклад демонструє, як клас може інтуїтивно інтегруватися з Python операторами порівняння, роблячи код, 
який використовує ці об'єкти, більш читабельним і природним."""

