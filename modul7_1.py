"""                                     Вступ

Привіт!

У цьому модулі ми продовжимо вивчати ООП у Python і познайомимось з новими конструкціями, 
характерними для нього.

Розглянемо такі теми:

 -Магічні методи класів, використання __str__ та __repr__ , _getitem__ та __setitem__
- Перевизначення математичних операторів + , - , / , // , % , *
- Перевизначення операторів порівняння <, <=, >, >=, ==, !=
- Управління атрибутами та методами в класах. Гетери та сетери
- Статичні та класові методи і їх використання всередині класів
- Функтори і магічний метод __**call__**
- Створення об'єкта ітератора та генератора
- Методи передачі значень у генератор
-Створення власних менеджерів контексту

В результаті проходження модуля, ти розшириш свій toolkit з обєктно-орієнтованого програмування у Python.


                                        7.1 Використання спеціальних методів для керування об'єктами
                                        
                        Магічні методи класів
                        
Як ми вже обговорювали, в мові програмування Python практично кожен елемент можна розглядати як об'єкт. Ця 
унікальна особливість Python робить його особливо гнучким і потужним інструментом у руках розробників. 
Об'єктно-орієнтоване програмування (ООП) у Python дозволяє модифікувати поведінку об'єктів, змінюючи їх поля 
з даними та/або методи. Це означає, що розробник має можливість не просто створювати дані структури, але й 
керувати їх поведінкою на найнижчому рівні.

Коли ми застосовуємо до об'єкта оператор, такий як + або -, насправді, ми викликаємо специфічний метод цього 
об'єкта. Такі методи визначають, як об'єкт повинен реагувати на використання певного оператора. Це правило 
стосується більшості операторів у Python, роблячи можливим дуже точне та гнучке управління поведінкою об'єктів.

Методи, що відповідають за визначену поведінку об'єктів при використанні операторів або інших синтаксичних 
конструкцій, називаються магічними методами. Хоча вони й отримали таку назву через свою здатність "за лаштунками" 
змінювати стандартну поведінку, насправді немає нічого магічного у тому, як вони працюють.

Магічні методи – це просто засоби, які мова програмування Python надає розробникам для реалізації операторного 
перевантаження та інших потужних механізмів.

Ось чому вираз a + b на низькому рівні трансформується в виклик a.__add__(b), перетворюючи стандартну операцію 
додавання на виклик методу, який може бути перевизначений за бажанням розробника. Така можливість дає велику волю 
у налаштуванні поведінки об'єктів, дозволяючи, наприклад, створювати складні числові типи або реалізовувати 
оператори для роботи з власними класами даних.

Детальний перелік "магічних" методів, їх призначення та приклади застосування можна знайти у спеціалізованих 
джерелах та документації по Python. Наприклад, за цим посиланням (https://minhhh.github.io/posts/a-guide-to-pythons-magic-methods), 
розміщено вичерпний матеріал, що описує ці методи з прикладами їх застосування, що є надзвичайно корисним ресурсом 
для глибшого розуміння та ефективного використання магічних методів у власних проєктах.

У рамках цього уроку ми детальніше розглянемо деякі з найбільш часто використовуваних магічних методів. Це допоможе 
нам зрозуміти, як за їх допомогою можна керувати основними операціями та поведінкою об'єктів у Python.

Важливо пам'ятати, що імена всіх магічних методів в Python дотримуються строгої номенклатури: вони складаються з літер 
нижнього регістру та символів підкреслення, починаючись і закінчуючись подвійним символом підкреслення (__). 
Ця конвенція не тільки сприяє єдності стилю кодування, але й робить магічні методи легко впізнаваними серед іншого коду.

Магічний метод, який ми найчастіше використовуємо, — це метод __init__. Як ми вже знаємо, метод відповідає за ініціалізацію 
об'єкта. Коли ви створюєте об'єкт класу, то спочатку створюється порожній об'єкт, який містить лише обов'язкові службові 
атрибути. Після того як об'єкт створено, автоматично викликається метод __init__, який ми можемо модифікувати під наші потреби."""

class Human:
    def __init__(self, name: str, age: int = 0):
        self.name = name
        self.age = age

    def say_hello(self) -> str:
        return f'Hello! I am {self.name}'

bill = Human('Bill')
print(bill.say_hello())
print(bill.age)

jill = Human('Jill', 20)
print(jill.say_hello())
print(jill.age)

# Виведення:
# Hello! I am Bill
# 0
# Hello! I am Jill
# 20

""" В цьому прикладі ми створили клас Human, у якому визначили метод __init__. У цьому методі ми додаємо об'єктам цього 
класу поля name та age. Зверніть увагу, що метод __init__ може приймати аргументи позиційні та/або іменні, як і будь-який 
інший метод. Коли ми створюємо об'єкт класу Human, ми повинні класу передати обов'язково хоча б один аргумент, оскільки 
метод __init__ повинен приймати обов'язково name.

Магічний метод __init__ не обов'язково повинен приймати аргументи та містити лише створення полів. Цей метод можна 
використовувати для реалізації будь-яких дій, які вам потрібні на етапі, коли об'єкт вже створений та його потрібно 
ініціалізувати.

Додамо перевірку віку, щоб встановити, чи є людина повнолітньою, і відповідне поле is_adult, а також використаємо 
метод __init__ для виклику іншого методу класу під час ініціалізації."""

class Human:
    def __init__(self, name: str, age: int = 0):
        self.name = name
        self.age = age
        # Виклик методу під час ініціалізації
        self.is_adult = self.__check_adulthood()  
        
        # Приклад логування
        print(f"Створено Human: {self.name}, Вік: {self.age}, Дорослий: {self.is_adult}")

    def say_hello(self) -> str:
        return f'Hello! I am {self.name}'

    def __check_adulthood(self) -> bool:
        return self.age >= 18

bill = Human('Bill')
print(bill.say_hello())
print(f"Вік: {bill.age}, Дорослий: {bill.is_adult}")

jill = Human('Jill', 20)
print(jill.say_hello())
print(f"Вік: {jill.age}, Дорослий: {jill.is_adult}")

# Виведення:
# Створено Human: Bill, Вік: 0, Дорослий: False
# Hello! I am Bill
# Вік: 0, Дорослий: False
# Створено Human: Jill, Вік: 20, Дорослий: True
# Hello! I am Jill
# Вік: 20, Дорослий: True

""" У цьому прикладі, коли створюється об'єкт класу Human, наш магічний метод __init__ виконує наступні дії. Він, як 
і було до цього, ініціалізує поля name та age. Але тепер він визначає, чи є особа дорослою, використовуючи метод 
check_adulthood, і зберігає результат в поле is_adult. Також ми додали рядок який виводить інформацію про створення 
об'єкта.

Отже метод __init__ може використовуватись не лише для простої ініціалізації полів, але й для виконання будь-яких 
інших додаткових операцій, необхідних для підготовки об'єкта до використання.                        


                        Методи __str__ та __repr__
                        
Магічні методи __str__ та __repr__ в Python відіграють ключову роль у представленні об'єктів у вигляді рядків. Знання 
та правильне використання цих методів дозволяє контролювати, як об'єкти вашого класу відображаються і використовуються, 
що є важливою частиною розробки Python програм.

Коли в інтерактивному режимі роботи з Python ми хочемо побачити вміст деякого об'єкту, ми просто пишемо його ім'я в 
консолі та інтерпретатор виводить рядком представлення цього об'єкта.

У консолі ми бачимо [1, 2] але ж ми не використовували функцію print, як це трапилось? За цей механізм внутрішнього 
читабельного представлення об'єктів відповідає магічний метод __repr__. Цей метод приймає лише один аргумент (звичайно це 
self) і повинен повертати рядок.

Метод __repr__ призначений для створення офіційного рядкового представлення об'єкта. Розробники використовують його для 
однозначного ідентифікування об'єкта або навіть для відтворення об'єкта в іншому місці коду. Таке представлення може бути 
надзвичайно корисним під час налагодження, оскільки воно дозволяє розробникам отримати точне уявлення про стан об'єкта.

Тому коли ми хочемо у випадках, коли застосунок повинен відобразити об'єкт, виводити якусь корисну інформацію, ми повинні 
модифікувати цей метод. Наприклад, клас точки на площині в Декартових координатах:"""

class Point:
    def __init__(self, x, y):
        self.x = x
        self.y = y

    def __repr__(self):
        return f"Point(x={self.x}, y={self.y})"

point = Point(2, 3)
print(repr(point))  # Виводить: Point(x=2, y=3)

""" Виконайте цей код у консолі Python і ви побачите Point(x=2, y=3).

Але головне призначення __repr__ це створення офіційного рядкового представлення об'єкта, яке можна використати для 
відновлення об'єкта. Метод __repr__ має повертати рядок, який, ідеально, міг би бути використаний в коді для відтворення 
об'єкта з тими самими даними.

    ☝ Використання __repr__ дозволяє розробникам отримати детальне представлення об'єкта, яке може бути використане для 
       точного відтворення об'єкта або для налагодження програми, допомагаючи ідентифікувати та виправляти помилки.

Це означає, що ви можете використовувати вираз, повернутий методом __repr__, як Python команду для створення нового об'єкта, 
який буде мати ті самі характеристики, що й оригінальний об'єкт. Ця особливість особливо корисна для налагодження, де ви 
можете легко відтворити об'єкти на основі їхнього __repr__ представлення.

Розглянемо наступний приклад з нашим класом Point:"""
class Point:
    def __init__(self, x: float, y: float):
        self.x = x
        self.y = y

    def __repr__(self):
        return f"Point(x={self.x}, y={self.y})"

original_point = Point(2, 3)
print(repr(original_point))  

# Використання рядка, повернутого __repr__, для створення нового об'єкта
new_point = eval(repr(original_point))
print(new_point)

# Виведення:
# Point(x=2, y=3)
# Point(x=2, y=3)

""" Ми створили об'єкт original_point класу Point та використали __repr__ для отримання його представлення 
repr(original_point). Далі ми можемо використовувати це представлення для створення нового об'єкта з такими 
ж атрибутами. Для цього використовують функцію eval, яка і створює новий об'єкт new_point з рядкового представлення.

Функція eval() використовується для виконання рядкового виразу як коду. Вона приймає рядок і виконує його як вираз 
Python, повертаючи результат виконання цього виразу. Коли метод __repr__ класу повертає рядок, його можна передати 
до eval(). Ідея полягає в тому, щоб виклик eval() з результатом __repr__ створив новий об'єкт, ідентичний оригіналу.

    ☝ Важливо пам'ятати про обережне використання eval(), оскільки виконання коду, отриманого з ненадійних джерел, 
    може призвести до серйозних проблем з безпекою.

Дуже схожий на метод __repr__, який відповідає за те, як об'єкт конвертується в рядок — це метод __str__. Коли ви 
викликаєте функцію str та передаєте їй якийсь об'єкт, то насправді цей об'єкт викликається магічним методом __str__.

Метод __str__ призначений для повернення рядкового представлення об'єкта, яке має бути читабельним і зрозумілим для 
людини. Коли ви викликаєте функцію str() для об'єкта або друкуєте об'єкт за допомогою print(), Python автоматично 
використовує метод __str__ вашого класу. Це дає вам, як розробнику, можливість визначити, як об'єкт має бути 
представлений у зрозумілій формі.

Тому важливо визначити метод __str__ у ваших класах: щоб надати інтуїтивно зрозуміле та зручне для читання 
представлення ваших об'єктів."""
class Human:
    def __init__(self, name: str, age: int):
        self.name = name
        self.age = age

    def __str__(self):
        return f"Human named {self.name} who is {self.age} years old"
    
    def __repr__(self):
        return f"Human({self.name}, {self.age})"

human = Human("Alice", 30)
print(human)

# Виведення:
# Human named Alice who is 30 years old

""" Наш метод __str__ призначений для повернення рядка, який є зрозумілим для кінцевого користувача. Якщо цей метод 
не визначено, Python використає метод __repr__ як запасний варіант для перетворення об'єкта в рядок.

В підсумку магічні методи __str__ та __repr__ є важливими інструментами в арсеналі Python розробника. Вони дозволяють 
не тільки краще контролювати, як об'єкти класу представлені, але й поліпшити досвід користувачів та спростити процес 
налагодження. Вивчення та використання цих методів забезпечить повне використання можливостей об'єктно-орієнтованого 
програмування в Python.


                        Методи __getitem__ та __setitem__
                        
                        
Квадратні дужки дозволяють нам звертатися до елементів послідовності за індексом або до елементів словника за ключем. 
Методи __getitem__ та __setitem__ в Python використовуються для налаштування доступу до елементів об'єкта за допомогою 
індексації або ключів, подібно до роботи зі списками чи словниками. Ці магічні методи дозволяють нашим класам імітувати 
контейнерні типи даних.

Метод __getitem__ визначає, як об'єкт класу повинен вести себе при доступі до його елементів за допомогою індексу або 
ключа. Він приймає ключ або індекс як аргумент і повинен повертати значення, асоційоване з цим ключем або індексом.

Метод __setitem__ визначає, як об'єкт повинен поводити себе при присвоєнні значення елементу за певним індексом або 
ключем. Він приймає два аргументи: ключ (або індекс) та значення, яке потрібно асоціювати з цим ключем.

Розглянемо клас SimpleDict, який імітує поведінку словника:"""
class SimpleDict:
    def __init__(self):
        self.__data = {}

    def __getitem__(self, key):
        return self.__data.get(key, "Key not found")

    def __setitem__(self, key, value):
        self.__data[key] = value

# Використання класу
simple_dict = SimpleDict()
simple_dict['name'] = 'Boris'
print(simple_dict['name'])  
print(simple_dict['age'])  

""" У прикладі, SimpleDict використовує внутрішній приватний словник __data для зберігання своїх елементів. Метод __getitem__ 
дозволяє отримати значення за ключем, а __setitem__ – встановити нове значення для ключа.

Виведення:
Boris
Key not found

Такий підхід робить клас більшгнучким і інтуїтивно зрозумілим для користувачів, які звикли працювати зі стандартними 
контейнерами Python. Використання __getitem__ та __setitem__ дозволяє об'єктам класу інтегруватися з функціями та 
конструкціями мови, призначеними для роботи з послідовностями або відображеннями, наприклад, циклами for, операторами in, 
функціями len(), і так далі.

Крім того, цей підхід підвищує гнучкість класу, дозволяючи додавати додаткову логіку перевірки або обробки при доступі до 
елементів або їх зміні. Наприклад, тепер можна легко імплементувати перевірку типів даних або логування без зміни 
зовнішнього інтерфейсу класу.

Уявімо, що нам потрібно створити структуру даних, яка схожа на список, але з обмеженням: елементи списку повинні 
завжди залишатися в певному діапазоні значень. Наприклад, ми працюємо над програмою для керування температурою в 
приміщенні, де значення температури повинні бути обмежені мінімальним та максимальним порогом.

Реалізація:"""

class BoundedList:
    def __init__(self, min_value: int, max_value: int):
        self.min_value = min_value
        self.max_value = max_value
        self.__data = []

    def __getitem__(self, index: int):
        return self.__data[index]

    def __setitem__(self, index: int, value: int):
        if not (self.min_value <= value <= self.max_value):
            raise ValueError(f"Value {value} must be between {self.min_value} and {self.max_value}")
        if index >= len(self.__data):
            # Додати новий елемент, якщо індекс виходить за межі
            self.__data.append(value)
        else:
            # Замінити існуючий елемент
            self.__data[index] = value

    def __repr__(self):
        return f"BoundedList({self.max_value}, {self.min_value})"

    def __str__(self):
        return str(self.__data)

if __name__ == '__main__':
    temperatures = BoundedList(18, 26)

    for i, el in enumerate([20, 22, 25, 27]):
        try:
            temperatures[i] = el
        except ValueError as e:
            print(e)

    print(temperatures)

# Виведення:
# Value 27 must be between 18 and 26
# [20, 22, 25]

""" Як бачимо спроба встановити значення поза дозволеним діапазоном призводить до виведення помилки 
"Value 27 must be between 18 and 26". Ми встановили температурні обмеження для значень, що зберігаються 
в структурі даних і що вони завжди відповідають певним критеріям. Ми просто не зможемо додати дані до 
нашого списку які не проходять обмеження.

Ми можемо об'єднати нашу реалізацію з можливостями класу UserList. Успадкувавшись від UserList, ми отримуємо 
всі можливості звичайного списку, але з можливістю модифікації поведінки за допомогою перевизначення методів 
або додавання нових.

Реалізація:"""

from collections import UserList

class BoundedList(UserList):
    def __init__(self, min_value: int, max_value: int, initial_list=None):
        super().__init__(initial_list if initial_list is not None else [])
        self.min_value = min_value
        self.max_value = max_value
        self.__validate_list()

    def __validate_list(self):
        for item in self.data:
            self.__validate_item(item)

    def __validate_item(self, item):
        if not (self.min_value <= item <= self.max_value):
            raise ValueError(f"Item {item} must be between {self.min_value} and {self.max_value}")

    def append(self, item):
        self.__validate_item(item)
        super().append(item)

    def insert(self, i, item):
        self.__validate_item(item)
        super().insert(i, item)

    def __setitem__(self, i, item):
        self.__validate_item(item)
        super().__setitem__(i, item)

    def __repr__(self):
        return f"BoundedList({self.max_value}, {self.min_value})"

    def __str__(self):
        return str(self.data)

if __name__ == '__main__':
    temperatures = BoundedList(18, 26, [19, 21, 22])
    print(temperatures)

    for el in [20, 22, 25, 27]:
        try:
            temperatures.append(el)
        except ValueError as e:
            print(e)

    print(temperatures)

# Виведення:
# [19, 21, 22]
# Item 27 must be between 18 and 26
# [19, 21, 22, 20, 22, 25]

""" Тепер клас BoundedList веде себе як список, але з додатковим обмеженням на значення елементів, що зберігаються 
в ньому. Використання UserList як базового класу спрощує реалізацію, оскільки нам не потрібно заново визначати багато 
методів, типових для списку; замість цього ми можемо зосередитися на логіці валідації даних.

Зверніть увагу, що ми не виконали реалізацію метода __getitem__. Бо коли ми успадкувались від UserList, ми отримали 
всю функціональність стандартного списку Python, але з можливістю перевизначення або додавання методів для 
налаштування поведінки. Таким чином, __getitem__ та інші методи доступу до елементів вже є частиною UserList, і 
вони працюватимуть як очікується, якщо тільки ми не вирішимо їх перевизначити для зміни поведінки.

Наприклад можна додати логування:

def __getitem__(self, index):
        # Додати спеціальну логіку тут, наприклад, логування або перевірку
        print(f"Accessing item at index {index}")
        # Викликати оригінальний метод __getitem__
        return super().__getitem__(index)  
"""