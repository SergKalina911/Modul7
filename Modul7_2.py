"""                                     Функтори, Ітератори та Управління контекстом в Python

                        Функтори, магічний метод __call__

Функтори в Python — це об'єкти класів, які можуть бути викликані як функції. Це досягається за допомогою реалізації 
спеціального магічного методу __call__ для класу. Коли ви додаєте метод __call__ до класу, екземпляри цього класу 
можуть бути викликані звичайні функції.

    ☝ Функтори — це об'єкти, які поводяться як функції у тому сенсі, що їх можна викликати та передавати їм 
    аргументи.

Функтори можуть бути корисними з кількох причин:
- Дозволяють об'єктам мати стан. Це означає, що функтор може зберігати стан між викликами.
- Функтори дозволяють об'єкту мати складну логіку виклику, яка може залежати від внутрішнього стану функтора або 
інших факторів.
- Вони можуть використовуватися для створення параметризованих, налаштовуваних або замкнутих функцій.

Для прикладу реалізуємо метод __call__ класу, роблячи його функтором:"""

class Multiplier:
    def __init__(self, factor):
        self.factor = factor

    def __call__(self, other):
        return self.factor * other

# Створення екземпляра функтора
double = Multiplier(2)
triple = Multiplier(3)

# Виклик функтора
print(double(5))  # Виведе: 10
print(triple(3))  # Виведе: 9
print(Multiplier(3)(4))  # Виведе: 12

""" Клас, Multiplier приймає один аргумент factor при ініціалізації. Метод __call__ дозволяє екземплярам Multiplier 
викликатися як функції, які множать передане їм значення на фактор, вказаний при створенні екземпляру. Це щось 
схоже на механізм замикання який ми розглядали раніше.

Розглянемо функтор зі станом. Він буде використовувати свій внутрішній стан для підрахунку кількості разів, коли 
його викликали."""

class Counter:
    def __init__(self):
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1

counter = Counter()
counter()
counter()
print(f"Викликано {counter.count} разів")

# Виведення:
# Викликано 2 разів

""" Функтор може містити в собі досить складну логіку. Розглянемо функтор який використовує внутрішній стан та 
додаткові параметри для вирішення, яку дію виконати при виклику. Цей функтор приймає параметри при ініціалізації, 
які потім використовуються для налаштування його поведінки."""

class SmartCalculator:
    def __init__(self, operation='add'):
        self.operation = operation

    def __call__(self, a, b):
        if self.operation == 'add':
            return a + b
        elif self.operation == 'subtract':
            return a - b
        else:
            raise ValueError("Невідома операція")

add = SmartCalculator('add')
print(add(5, 3))  # 8

subtract = SmartCalculator('subtract')
print(subtract(10, 7))  # 3
"""
В залежності від свого стану функтор виконує операції додавання чи віднімання над числами. Виведення:
8
3

Наш клас SmartCalculator створює замкнуті функції із заданими параметрами. Об'єкт add функтор додавання чисел, а 
subtract - віднімання.

Функтори в Python — потужний інструмент, який дозволяє класам імітувати поведінку функцій і при цьому мати власний 
внутрішній стан та логіку. Вони можуть зробити код більш гнучким, додавши об'єктно-орієнтовані можливості до 
функціонального стилю програмування.


                        Створення об'єкта ітератора/генератора

Ітератор в Python — це об'єкт, який дозволяє нам послідовно перебирати елементи будь-якого об'єкта ітерації 
(наприклад, списку, кортежу, словника) без потреби використання індексів. Він реалізує методи
__iter__() та __next__() та дозволяє перебирати елементи послідовності, не завантажуючи всю послідовність у пам'ять.

Метод __iter__() повертає сам ітератор, а метод __next__() повертає наступний елемент об'єкта ітерації. Коли 
елементи ітератора закінчуються, має бути викинуто виняток StopIteration, що сигналізує про завершення ітерації.

Оскільки ітератор дозволяє нам перебирати елементи контейнера за допомогою циклу for-in, то основна ідея полягає в 
тому, що ітератор зберігає поточний стан перебору, дозволяючи вам отримувати наступний елемент за допомогою методу 
__next__().

Коли ви використовуєте цикл for-in для перебору елементів контейнера, Python автоматично викликає метод __iter__() 
контейнера, щоб отримати ітератор. Потім, на кожній ітерації циклу, викликається метод __next__() ітератора для 
отримання наступного елемента, поки не буде піднято виняток StopIteration, що означає завершення перебору.

Створимо для демонстрації простий ітератор."""

class CountDown:
    def __init__(self, start):
        self.current = start

    def __iter__(self):
        return self

    def __next__(self):
        if self.current == 0:
            raise StopIteration
        self.current -= 1
        return self.current

if __name__ == '__main__':
    counter = CountDown(5)
    for count in counter:
        print(count)

# Виведення:
# 4
# 3
# 2
# 1
# 0

""" Цей приклад створює ітератор CountDown, який починає відлік з заданого числа і зменшує його до 0. Метод 
__iter__() повертає об'єкт ітератора і це self, бо наш клас має метод __next__(). Метод __next__() повертає 
наступний елемент контейнера.

self.current -= 1
return self.current

Зверніть увагу, що метод __next__ повинен викликати виняток StopIteration, щоб вказати, що ітерування завершено, 
накше цикл for за таким об'єктом буде нескінченний.

if self.current == 0:
    raise StopIteration

    ☝ Виконати перебір ітератора можна тільки один раз. У цьому сенсі ітератор являє собою "одноразовий" об'єкт. 
    Якщо нам потрібно ще раз виконати перебір, то доведеться створювати новий ітератор.

Але це можна реалізувати через генератор з яким ми вже мали справу. Генератор - це спрощений спосіб створення 
ітераторів. Функція стає генератором, коли містить вираз yield. Генератор автоматично реалізує методи __iter__() 
та __next__()."""

def count_down(start):
    current = start
    current -= 1
    while current >= 0:
        yield current
        current -= 1

# Використання генератора
for count in count_down(5):
    print(count)

# Виведення:
# 4
# 3
# 2
# 1
# 0

""" Цей генератор виконує ту саму функцію, що й ітератор CountDown, але з меншим обсягом коду та більшою 
читабельністю.

Розглянемо наступний приклад. Створимо клас RandIterator, який використовується для генерації обмеженої кількості 
випадкових чисел в заданому діапазоні. Коли ми створимо екземпляр цього класу, ми вкажемо початкове та кінцеве 
значення діапазону start і end та кількість чисел quantity, які ми хочемо згенерувати.

Реалізація:"""

from random import randint
class RandIterator:
    def __init__(self, start, end, quantity):
        self.start = start
        self.end = end
        self.quantity = quantity
        self.count = 0

    def __iter__(self):
        return self

    def __next__(self):
        self.count += 1
        if self.count > self.quantity:
            raise StopIteration
        else:
            return randint(self.start, self.end)

if __name__ == '__main__':
    my_random_list = RandIterator(1, 20, 5)

    for rn in my_random_list:
        print(rn, end=' ')

# Виведення це набір випадкових чисел з діапазону [1, 20]:
# 14 8 15 13 16

""" Наш клас реалізує два основних методи, які роблять його ітератором: __iter__() та __next__(). Метод __iter__() 
просто повертає self класу як ітератор. Метод __next__() використовується для генерації наступного випадкового 
числа кожного разу, коли він викликається. Він збільшує лічильник self.count на одиницю при кожному виклику і 
генерує нове випадкове число за допомогою randint(self.start, self.end). Як тільки кількість згенерованих чисел 
досягає вказаної при створенні екземпляру quantity, метод __next__() викидає виняток StopIteration, що сигналізує 
про завершення ітерації.

У результаті, коли ми використовуємо наш ітератор в циклі for, він дозволяє послідовно отримувати випадкові числа в 
заданому діапазоні [start, end], але не більше зазначеної кількості quantity.

Щоб перетворити ітератор на генератор, ми можемо використати функцію з ключовим словом yield замість класу з 
методами __iter__() та __next__(). Генератор автоматично веде облік свого стану в місці кожного виклику yield і 
відновлює виконання з цього місця при наступному виклику."""

from random import randint

def rand_generator(start, end, quantity):
    count = 0
    while count < quantity:
        yield randint(start, end)
        count += 1

if __name__ == '__main__':
    for rn in rand_generator(1, 20, 5):
        print(rn, end=' ')

# Виведення це знову набір випадкових чисел з діапазону [1, 20]:
# 11 1 7 9 4

""" У цьому варіанті функція rand_generator є генератором, який приймає ті самі аргументи: start, end, та quantity. 
Генератор ініціалізує лічильник count з нуля і використовує цикл while для генерації випадкових чисел в заданому 
діапазоні. Кожного разу, коли генератор досягає оператора yield, він повертає випадкове число і "заморожує" свій 
стан до наступного виклику.

Як бачимо такий підхід значно спрощує код, зберігаючи при цьому ту саму функціональність: генерація обмеженої 
кількості випадкових чисел в заданому діапазоні. Генератори є потужним інструментом у Python для створення 
ітераторів з меншими зусиллями та більш читабельним кодом.

Отже в підсумку.

Ітератор - це об'єкт, який дозволяє користувачу перебирати всі елементи контейнера без потреби знати внутрішню 
структуру контейнера. Реалізується за допомогою методів __iter__() та __next__(). Метод __iter__() повертає об'єкт 
ітератора, а метод __next__() автоматично викликається циклом for або функцією next() для отримання наступного 
елемента контейнера. Щоб створити ітератор, потрібно визначити клас з цими двома методами.

Генератор - це функція, яка дозволяє декларативно створювати ітератор за допомогою ключового слова yield. Він 
автоматично реалізує методи __iter__() та __next__(), тому більше не потрібно їх явно визначати. Створення 
генератора - це просто написання функції, яка використовує yield для повернення наступного значення.

Генератори можуть бути більш ефективними за ітератори, коли мова йдеться про великі обсяги даних або складні 
обчислення, оскільки вони генерують значення "на льоту" і не зберігають усі значення в пам'яті. Вони особливо 
ефективні коли потрібно обробляти великі обсяги даних або виконувати складні обчислення з мінімальним 
навантаженням на пам'ять.


                        Передача значень у генератор

Оператор yield має більш рідкісне застосування, він може повертати значення так само, як і виклик функції. Це 
дозволяє передавати значення в генератор за допомогою виклику методу send.

Метод send() використовується для взаємодії з генератором шляхом надсилання значення у генератор, яке потім може 
бути використане як результат виразу yield. Це дозволяє генератору не лише виробляти дані, але й обробляти зовнішні 
дані на кожній ітерації."""

def my_generator():
    received = yield "Ready"
    yield f"Received: {received}"

gen = my_generator()
print(next(gen))  
print(gen.send("Hello"))  

""" Метод send() використовується для передачі значення безпосередньо в генератор. Значення, передане через send(), 
стає результатом виразу yield, де генератор був призупинений. Це дозволяє генераторам не тільки виробляти значення, 
але й приймати дані в будь-який момент їх виконання.

Виведення:
Ready
Received: Hello

Запускаємо генератор next(gen) і отримуємо перше повідомлення "Ready" . Відправляємо дані в генератор 
gen.send("Hello") і отримуємо наступне значення "Received: Hello".

Коли генератору більше не потрібно виробляти значення, його можна закрити за допомогою методу close(). При цьому в 
генераторі викликається виключення GeneratorExit, яке можна перехопити для виконання якихось дій перед закриттям 
генератора."""

def my_generator():
    try:
        yield "Working"
    except GeneratorExit:
        print("Generator is being closed")

gen = my_generator()
print(next(gen))  # Отримуємо "Working"
gen.close()  # Викликаємо закриття генератора

# Виведення:
# Working
# Generator is being closed

""" Ці механізми дозволяють реалізувати досить складну логіку взаємодії між кодом та генераторами, забезпечуючи 
гнучкість та контроль над процесом виконання генераторів.

Для прикладу створимо генератор, який може приймати рядки тексту, фільтрувати їх за певним критерієм (наприклад, 
повертати рядок, якщо він містить певне слово), і повертати тільки ті рядки, які відповідають цьому критерію.

Спочатку розглянемо простий приклад. Створимо генератор square_numbers() , який буде приймати числа через метод 
send() та виконувати обчислення, візьмемо просту операцію піднесення до квадрату, та повертати результат через 
yield."""

def square_numbers():
    try:
        while True:  # Безкінечний цикл для прийому чисел
            number = yield  # Отримання числа через send()
            square = number ** 2  # Піднесення до квадрата
            yield square  # Повернення результату
    except GeneratorExit:
        print("Generator closed")

# Створення і старт генератора
gen = square_numbers()

# Ініціалізація генератора
next(gen)  # Або gen.send(None), щоб стартувати

# Відправлення числа в генератор і отримання результату
result = gen.send(10)  # Повинно повернути 100
print(f"Square of 10: {result}")

# Перехід до наступного очікування
next(gen)

# Відправлення іншого числа
result = gen.send(5)  # Повинно повернути 25
print(f"Square of 5: {result}")

# Закриття генератора
gen.close()

# Виведення:
# Square of 10: 100
# Square of 5: 25
# Generator closed

""" Ми створили генератор square_numbers, що приймає числа, підносить їх до квадрату, та повертає результат. В 
середині генератора ми використовуємо yield двічі. Спочатку для отримання числа через send() - інструкція 
number = yield. Потім для повернення обчисленого квадрату числа - інструкція yield square.

В коді після кожного виклику send(), що передає число, нам потрібно викликати next(gen) або знову send(), щоб 
продовжити виконання генератора до наступного yield. Це як раз і дозволяє генератору приймати нове значення.

Тепер розглянемо більш складний приклад. Створимо генератор filter_lines(), який чекатиме на вхідні рядки через 
метод send(). Всередині генератора буде перевірка: якщо рядок містить певне слово, він буде повернутий через yield."""

def filter_lines(keyword):
    print(f"Looking for {keyword}")
    try:
        while True:  # Нескінченний цикл, де генератор чекає на вхідні дані
            line = yield  # Отримання рядка через send()
            if keyword in line:  # Перевірка на наявність ключового слова
                yield f"Line accepted: {line}"
            else:
                yield None
    except GeneratorExit:
        print("Generator closed")

if __name__ == "__main__":
    # Створення і старт генератора
    gen = filter_lines("hello")
    next(gen)  # Потрібно для старту генератора
    messages = ["this is a test", "hello world", "another hello world line", "hello again", "goodbye"]
    hello_messages = []
    # Відправлення даних у генератор
    for message in messages:
        result = gen.send(message)  # Відправляємо повідомлення в генератор
        if result:  # Додаємо результат тільки якщо він не None
            hello_messages.append(result)
        next(gen)  # Продовжуємо до наступного yield: інструкція line = yield

    # Закриття генератора
    gen.close()
    print(hello_messages)

# Виведення:
# Looking for hello
# Generator closed
# ['Line accepted: hello world', 'Line accepted: another hello world line', 'Line accepted: hello again']

""" Спочатку ми створюємо і ініціалізуємо генератор filter_lines, вказуючи ключове слово для фільтрації.

gen = filter_lines("hello")

Потім ми активуємо генератор за допомогою next(gen). Це необхідно, щоб "дійти" до першого yield і підготувати 
генератор до прийому даних через send().

next(gen)  # Потрібно для старту генератора

Після активації ми відправляємо рядки в генератор через send(). Кожен раз, коли рядок містить ключове слово, 
генератор повертає рядок з відповідним повідомленням. Ми перевіряємо, чи повернене значення не є None, і якщо воно 
відповідає нашому критерію, додаємо його до списку hello_messages:

for message in messages:
    result = gen.send(message)  # Відправляємо повідомлення в генератор
    if result:  # Додаємо результат тільки якщо він не None
        hello_messages.append(result)
    next(gen)  # Продовжуємо до наступного yield

Тут, після кожного виклику send(), ми робимо додатковий виклик next(gen) для просування генератора через наступний 
цикл, дозволяючи йому приймати наступне значення. Це важливо, оскільки після yield, які повертають значення, наш 
генератор "зупиняється".

if keyword in line:  # Перевірка на наявність ключового слова
    yield f"Line accepted: {line}"
else:
    yield None

І щоб продовжити роботу генератора нам потрібен або виклик next(), або send(). Це змусить генератор перейти до 
рядка коду:

 line = yield  # Отримання рядка через send()

На завершення, ми закриваємо генератор за допомогою close(), щоб коректно завершити його роботу і викликати 
виключення GeneratorExit всередині генератора. Це гарантує, що всі ресурси належним чином звільняються, а генератор 
припиняє свою роботу.

Загалом такий підхід робить генератори потужним інструментом для асинхронного програмування, обробки потоків даних 
та реалізації кооперативної багатозадачності в Python.
"""