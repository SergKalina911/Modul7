"""                                     Функтори, Ітератори та Управління контекстом в Python

                        Функтори, магічний метод __call__

Функтори в Python — це об'єкти класів, які можуть бути викликані як функції. Це досягається за допомогою реалізації 
спеціального магічного методу __call__ для класу. Коли ви додаєте метод __call__ до класу, екземпляри цього класу 
можуть бути викликані звичайні функції.

    ☝ Функтори — це об'єкти, які поводяться як функції у тому сенсі, що їх можна викликати та передавати їм 
    аргументи.

Функтори можуть бути корисними з кількох причин:
- Дозволяють об'єктам мати стан. Це означає, що функтор може зберігати стан між викликами.
- Функтори дозволяють об'єкту мати складну логіку виклику, яка може залежати від внутрішнього стану функтора або 
інших факторів.
- Вони можуть використовуватися для створення параметризованих, налаштовуваних або замкнутих функцій.

Для прикладу реалізуємо метод __call__ класу, роблячи його функтором:"""

class Multiplier:
    def __init__(self, factor):
        self.factor = factor

    def __call__(self, other):
        return self.factor * other

# Створення екземпляра функтора
double = Multiplier(2)
triple = Multiplier(3)

# Виклик функтора
print(double(5))  # Виведе: 10
print(triple(3))  # Виведе: 9
print(Multiplier(3)(4))  # Виведе: 12

""" Клас, Multiplier приймає один аргумент factor при ініціалізації. Метод __call__ дозволяє екземплярам Multiplier 
викликатися як функції, які множать передане їм значення на фактор, вказаний при створенні екземпляру. Це щось 
схоже на механізм замикання який ми розглядали раніше.

Розглянемо функтор зі станом. Він буде використовувати свій внутрішній стан для підрахунку кількості разів, коли 
його викликали."""

class Counter:
    def __init__(self):
        self.count = 0

    def __call__(self, *args, **kwargs):
        self.count += 1

counter = Counter()
counter()
counter()
print(f"Викликано {counter.count} разів")

# Виведення:
# Викликано 2 разів

""" Функтор може містити в собі досить складну логіку. Розглянемо функтор який використовує внутрішній стан та 
додаткові параметри для вирішення, яку дію виконати при виклику. Цей функтор приймає параметри при ініціалізації, 
які потім використовуються для налаштування його поведінки."""

class SmartCalculator:
    def __init__(self, operation='add'):
        self.operation = operation

    def __call__(self, a, b):
        if self.operation == 'add':
            return a + b
        elif self.operation == 'subtract':
            return a - b
        else:
            raise ValueError("Невідома операція")

add = SmartCalculator('add')
print(add(5, 3))  # 8

subtract = SmartCalculator('subtract')
print(subtract(10, 7))  # 3
"""
В залежності від свого стану функтор виконує операції додавання чи віднімання над числами. Виведення:
8
3

Наш клас SmartCalculator створює замкнуті функції із заданими параметрами. Об'єкт add функтор додавання чисел, а 
subtract - віднімання.

Функтори в Python — потужний інструмент, який дозволяє класам імітувати поведінку функцій і при цьому мати власний 
внутрішній стан та логіку. Вони можуть зробити код більш гнучким, додавши об'єктно-орієнтовані можливості до 
функціонального стилю програмування.


                        Створення об'єкта ітератора/генератора

Ітератор в Python — це об'єкт, який дозволяє нам послідовно перебирати елементи будь-якого об'єкта ітерації 
(наприклад, списку, кортежу, словника) без потреби використання індексів. Він реалізує методи
__iter__() та __next__() та дозволяє перебирати елементи послідовності, не завантажуючи всю послідовність 
у пам'ять.

Метод __iter__() повертає сам ітератор, а метод __next__() повертає наступний елемент об'єкта ітерації. Коли 
елементи ітератора закінчуються, має бути викинуто виняток StopIteration, що сигналізує про завершення ітерації.

Оскільки ітератор дозволяє нам перебирати елементи контейнера за допомогою циклу for-in, то основна ідея полягає в 
тому, що ітератор зберігає поточний стан перебору, дозволяючи вам отримувати наступний елемент за допомогою методу 
__next__().

Коли ви використовуєте цикл for-in для перебору елементів контейнера, Python автоматично викликає метод __iter__() 
контейнера, щоб отримати ітератор. Потім, на кожній ітерації циклу, викликається метод __next__() ітератора для 
отримання наступного елемента, поки не буде піднято виняток StopIteration, що означає завершення перебору.

Створимо для демонстрації простий ітератор."""

class CountDown:
    def __init__(self, start):
        self.current = start

    def __iter__(self):
        return self

    def __next__(self):
        if self.current == 0:
            raise StopIteration
        self.current -= 1
        return self.current

if __name__ == '__main__':
    counter = CountDown(5)
    for count in counter:
        print(count)

# Виведення:
# 4
# 3
# 2
# 1
# 0

""" Цей приклад створює ітератор CountDown, який починає відлік з заданого числа і зменшує його до 0. Метод 
__iter__() повертає об'єкт ітератора і це self, бо наш клас має метод __next__(). Метод __next__() повертає 
наступний елемент контейнера.

self.current -= 1
return self.current

Зверніть увагу, що метод __next__ повинен викликати виняток StopIteration, щоб вказати, що ітерування завершено, 
накше цикл for за таким об'єктом буде нескінченний.

if self.current == 0:
    raise StopIteration

    ☝ Виконати перебір ітератора можна тільки один раз. У цьому сенсі ітератор являє собою "одноразовий" об'єкт. 
    Якщо нам потрібно ще раз виконати перебір, то доведеться створювати новий ітератор.

Але це можна реалізувати через генератор з яким ми вже мали справу. Генератор - це спрощений спосіб створення 
ітераторів. Функція стає генератором, коли містить вираз yield. Генератор автоматично реалізує методи __iter__() 
та __next__()."""

def count_down(start):
    current = start
    current -= 1
    while current >= 0:
        yield current
        current -= 1

# Використання генератора
for count in count_down(5):
    print(count)

# Виведення:
# 4
# 3
# 2
# 1
# 0

""" Цей генератор виконує ту саму функцію, що й ітератор CountDown, але з меншим обсягом коду та більшою 
читабельністю.

Розглянемо наступний приклад. Створимо клас RandIterator, який використовується для генерації обмеженої кількості 
випадкових чисел в заданому діапазоні. Коли ми створимо екземпляр цього класу, ми вкажемо початкове та кінцеве 
значення діапазону start і end та кількість чисел quantity, які ми хочемо згенерувати.

Реалізація:"""

from random import randint
class RandIterator:
    def __init__(self, start, end, quantity):
        self.start = start
        self.end = end
        self.quantity = quantity
        self.count = 0

    def __iter__(self):
        return self

    def __next__(self):
        self.count += 1
        if self.count > self.quantity:
            raise StopIteration
        else:
            return randint(self.start, self.end)

if __name__ == '__main__':
    my_random_list = RandIterator(1, 20, 5)

    for rn in my_random_list:
        print(rn, end=' ')

# Виведення це набір випадкових чисел з діапазону [1, 20]:
# 14 8 15 13 16

""" Наш клас реалізує два основних методи, які роблять його ітератором: __iter__() та __next__(). Метод __iter__() 
просто повертає self класу як ітератор. Метод __next__() використовується для генерації наступного випадкового 
числа кожного разу, коли він викликається. Він збільшує лічильник self.count на одиницю при кожному виклику і 
генерує нове випадкове число за допомогою randint(self.start, self.end). Як тільки кількість згенерованих чисел 
досягає вказаної при створенні екземпляру quantity, метод __next__() викидає виняток StopIteration, що сигналізує 
про завершення ітерації.

У результаті, коли ми використовуємо наш ітератор в циклі for, він дозволяє послідовно отримувати випадкові числа в 
заданому діапазоні [start, end], але не більше зазначеної кількості quantity.

Щоб перетворити ітератор на генератор, ми можемо використати функцію з ключовим словом yield замість класу з 
методами __iter__() та __next__(). Генератор автоматично веде облік свого стану в місці кожного виклику yield і 
відновлює виконання з цього місця при наступному виклику."""

from random import randint

def rand_generator(start, end, quantity):
    count = 0
    while count < quantity:
        yield randint(start, end)
        count += 1

if __name__ == '__main__':
    for rn in rand_generator(1, 20, 5):
        print(rn, end=' ')

# Виведення це знову набір випадкових чисел з діапазону [1, 20]:
# 11 1 7 9 4

""" У цьому варіанті функція rand_generator є генератором, який приймає ті самі аргументи: start, end, та quantity. 
Генератор ініціалізує лічильник count з нуля і використовує цикл while для генерації випадкових чисел в заданому 
діапазоні. Кожного разу, коли генератор досягає оператора yield, він повертає випадкове число і "заморожує" свій 
стан до наступного виклику.

Як бачимо такий підхід значно спрощує код, зберігаючи при цьому ту саму функціональність: генерація обмеженої 
кількості випадкових чисел в заданому діапазоні. Генератори є потужним інструментом у Python для створення 
ітераторів з меншими зусиллями та більш читабельним кодом.

Отже в підсумку.

Ітератор - це об'єкт, який дозволяє користувачу перебирати всі елементи контейнера без потреби знати внутрішню 
структуру контейнера. Реалізується за допомогою методів __iter__() та __next__(). Метод __iter__() повертає об'єкт 
ітератора, а метод __next__() автоматично викликається циклом for або функцією next() для отримання наступного 
елемента контейнера. Щоб створити ітератор, потрібно визначити клас з цими двома методами.

Генератор - це функція, яка дозволяє декларативно створювати ітератор за допомогою ключового слова yield. Він 
автоматично реалізує методи __iter__() та __next__(), тому більше не потрібно їх явно визначати. Створення 
генератора - це просто написання функції, яка використовує yield для повернення наступного значення.

Генератори можуть бути більш ефективними за ітератори, коли мова йдеться про великі обсяги даних або складні 
обчислення, оскільки вони генерують значення "на льоту" і не зберігають усі значення в пам'яті. Вони особливо 
ефективні коли потрібно обробляти великі обсяги даних або виконувати складні обчислення з мінімальним 
навантаженням на пам'ять.


                        Передача значень у генератор

Оператор yield має більш рідкісне застосування, він може повертати значення так само, як і виклик функції. Це 
дозволяє передавати значення в генератор за допомогою виклику методу send.

Метод send() використовується для взаємодії з генератором шляхом надсилання значення у генератор, яке потім може 
бути використане як результат виразу yield. Це дозволяє генератору не лише виробляти дані, але й обробляти зовнішні 
дані на кожній ітерації."""

def my_generator():
    received = yield "Ready"
    yield f"Received: {received}"

gen = my_generator()
print(next(gen))  
print(gen.send("Hello"))  

""" Метод send() використовується для передачі значення безпосередньо в генератор. Значення, передане через send(), 
стає результатом виразу yield, де генератор був призупинений. Це дозволяє генераторам не тільки виробляти значення, 
але й приймати дані в будь-який момент їх виконання.

Виведення:
Ready
Received: Hello

Запускаємо генератор next(gen) і отримуємо перше повідомлення "Ready" . Відправляємо дані в генератор 
gen.send("Hello") і отримуємо наступне значення "Received: Hello".

Коли генератору більше не потрібно виробляти значення, його можна закрити за допомогою методу close(). При цьому в 
генераторі викликається виключення GeneratorExit, яке можна перехопити для виконання якихось дій перед закриттям 
генератора."""

def my_generator():
    try:
        yield "Working"
    except GeneratorExit:
        print("Generator is being closed")

gen = my_generator()
print(next(gen))  # Отримуємо "Working"
gen.close()  # Викликаємо закриття генератора

# Виведення:
# Working
# Generator is being closed

""" Ці механізми дозволяють реалізувати досить складну логіку взаємодії між кодом та генераторами, забезпечуючи 
гнучкість та контроль над процесом виконання генераторів.

Для прикладу створимо генератор, який може приймати рядки тексту, фільтрувати їх за певним критерієм (наприклад, 
повертати рядок, якщо він містить певне слово), і повертати тільки ті рядки, які відповідають цьому критерію.

Спочатку розглянемо простий приклад. Створимо генератор square_numbers() , який буде приймати числа через метод 
send() та виконувати обчислення, візьмемо просту операцію піднесення до квадрату, та повертати результат через 
yield."""

def square_numbers():
    try:
        while True:  # Безкінечний цикл для прийому чисел
            number = yield  # Отримання числа через send()
            square = number ** 2  # Піднесення до квадрата
            yield square  # Повернення результату
    except GeneratorExit:
        print("Generator closed")

# Створення і старт генератора
gen = square_numbers()

# Ініціалізація генератора
next(gen)  # Або gen.send(None), щоб стартувати

# Відправлення числа в генератор і отримання результату
result = gen.send(10)  # Повинно повернути 100
print(f"Square of 10: {result}")

# Перехід до наступного очікування
next(gen)

# Відправлення іншого числа
result = gen.send(5)  # Повинно повернути 25
print(f"Square of 5: {result}")

# Закриття генератора
gen.close()

# Виведення:
# Square of 10: 100
# Square of 5: 25
# Generator closed

""" Ми створили генератор square_numbers, що приймає числа, підносить їх до квадрату, та повертає результат. В 
середині генератора ми використовуємо yield двічі. Спочатку для отримання числа через send() - інструкція 
number = yield. Потім для повернення обчисленого квадрату числа - інструкція yield square.

В коді після кожного виклику send(), що передає число, нам потрібно викликати next(gen) або знову send(), щоб 
продовжити виконання генератора до наступного yield. Це як раз і дозволяє генератору приймати нове значення.

Тепер розглянемо більш складний приклад. Створимо генератор filter_lines(), який чекатиме на вхідні рядки через 
метод send(). Всередині генератора буде перевірка: якщо рядок містить певне слово, він буде повернутий через yield."""

def filter_lines(keyword):
    print(f"Looking for {keyword}")
    try:
        while True:  # Нескінченний цикл, де генератор чекає на вхідні дані
            line = yield  # Отримання рядка через send()
            if keyword in line:  # Перевірка на наявність ключового слова
                yield f"Line accepted: {line}"
            else:
                yield None
    except GeneratorExit:
        print("Generator closed")

if __name__ == "__main__":
    # Створення і старт генератора
    gen = filter_lines("hello")
    next(gen)  # Потрібно для старту генератора
    messages = ["this is a test", "hello world", "another hello world line", "hello again", "goodbye"]
    hello_messages = []
    # Відправлення даних у генератор
    for message in messages:
        result = gen.send(message)  # Відправляємо повідомлення в генератор
        if result:  # Додаємо результат тільки якщо він не None
            hello_messages.append(result)
        next(gen)  # Продовжуємо до наступного yield: інструкція line = yield

    # Закриття генератора
    gen.close()
    print(hello_messages)

# Виведення:
# Looking for hello
# Generator closed
# ['Line accepted: hello world', 'Line accepted: another hello world line', 'Line accepted: hello again']

""" Спочатку ми створюємо і ініціалізуємо генератор filter_lines, вказуючи ключове слово для фільтрації.

gen = filter_lines("hello")

Потім ми активуємо генератор за допомогою next(gen). Це необхідно, щоб "дійти" до першого yield і підготувати 
генератор до прийому даних через send().

next(gen)  # Потрібно для старту генератора

Після активації ми відправляємо рядки в генератор через send(). Кожен раз, коли рядок містить ключове слово, 
генератор повертає рядок з відповідним повідомленням. Ми перевіряємо, чи повернене значення не є None, і якщо воно 
відповідає нашому критерію, додаємо його до списку hello_messages:

for message in messages:
    result = gen.send(message)  # Відправляємо повідомлення в генератор
    if result:  # Додаємо результат тільки якщо він не None
        hello_messages.append(result)
    next(gen)  # Продовжуємо до наступного yield

Тут, після кожного виклику send(), ми робимо додатковий виклик next(gen) для просування генератора через наступний 
цикл, дозволяючи йому приймати наступне значення. Це важливо, оскільки після yield, які повертають значення, наш 
генератор "зупиняється".

if keyword in line:  # Перевірка на наявність ключового слова
    yield f"Line accepted: {line}"
else:
    yield None

І щоб продовжити роботу генератора нам потрібен або виклик next(), або send(). Це змусить генератор перейти до 
рядка коду:

 line = yield  # Отримання рядка через send()

На завершення, ми закриваємо генератор за допомогою close(), щоб коректно завершити його роботу і викликати 
виключення GeneratorExit всередині генератора. Це гарантує, що всі ресурси належним чином звільняються, а генератор 
припиняє свою роботу.

Загалом такий підхід робить генератори потужним інструментом для асинхронного програмування, обробки потоків даних 
та реалізації кооперативної багатозадачності в Python.


                        Створення власних менеджерів контексту

Створення власного менеджера контексту в Python - це спосіб керування ресурсами, такими як файли, з'єднання з базою 
даних та інше, забезпечуючи їх автоматичне відкриття та закриття. Менеджер контексту гарантує, що ресурси будуть 
коректно звільнені після завершення блоку коду, навіть якщо в процесі виконання виникне виключення.

Об'єкти контекстних менеджерів слугують для управління оператором with ... as ...: так само як ітератори управляють 
оператором циклу for-in.

Для створення власного менеджера контексту необхідно реалізувати клас з магічними методами __enter__ та __exit__. 
Метод __enter__ викликається на початку блоку with, коли інтерпретатор заходить у контекст і те, що він поверне, 
буде записано в змінну після as. Метод __exit__ викликається після завершення виконання блоку with, незалежно від 
того, виникло виключення чи ні.

Розглянемо поки досить абстрактний контекстний менеджер, щоб зрозуміти принцип його роботи."""

class MyContextManager:
    def __enter__(self):
        # Ініціалізація ресурсу
        print("Enter the block")
        return self  # Може повертати об'єкт

    def __exit__(self, exc_type, exc_value, traceback):
        # Звільнення ресурсу
        print("Exit the block")
        if exc_type:
            print(f"Error detected: {exc_value}")
        # Повернення False передає виключення далі, True - поглинає виключення.
        return False

# Використання власного менеджера контексту
try:
    with MyContextManager() as my_resource:
        print("Inside the block")
        raise Exception("Something went wrong")
except Exception as e:
    print(f"Caught an exception: {e}")
# Виведення:
# Enter the block
# Inside the block
# Exit the block
# Error detected: Something went wrong
# Caught an exception: Something went wrong

""" На початку блоку with автоматично викликається метод __enter__ нашого класу MyContextManager. Метод друкує 
рядок тексту "Enter the block" і повертає self, який прив'язується до змінної my_resource. Однак у даному контексті 
ми не використовуємо його.

Далі виконується код всередині блоку with. У нашому прикладі це виведення рядка "Inside the block" та генерація 
виключення за допомогою raise Exception("Something went wrong").

Після генерації виключення, або просто після завершення виконання коду, якщо виключення не було, автоматично 
викликається метод __exit__. Цей метод використовується для виконання необхідних дій по звільненню ресурсів або 
очищенню. Метод __exit__ отримує інформацію про виключення, яке сталося всередині блоку with, через свої параметри 
exc_type, exc_value і traceback. У нашому випадку, оскільки виключення відбулося, exc_type не буде None, і метод 
__exit__ друкує рядок "Exit the block" та "Error detected: Something went wrong".

Оскільки в методі __exit__ ми повертаємо False, то виключення, яке було згенеровано всередині блоку with, не 
придушується і, як кажуть програмісти, прокидається далі. Це означає, що після виходу з методу __exit__, виключення 
буде оброблене інтерпретатором звичайним чином, що і призводить до виведення його Traceback помилки в консолі. Отже 
як працює виконання контекстного менеджеру ми розібрали.

Тепер поглянемо уважно на синтаксис методу __exit__. Він приймає три аргументи, які містять інформацію про будь-яке 
виключення, що виникло всередині блоку with.

def __exit__(self, exc_type, exc_val, exc_tb):
    # Звільнення ресурсів
    # exc_type: тип виключення
    # exc_val: значення виключення
    # exc_tb: трасування стека виключення
    return False  # Якщо True, виключення буде придушено, інакше - прокинуто далі

Якщо блок with завершився без помилки, то значення змінних exc_type , exc_val , exc_tb дорівнюють None . Але якщо 
була помилка, як в нашому прикладі то параметр exc_type буде зберігати тип виключення <class 'Exception'>, 
exc_val значення виключення "Something went wrong" і exc_tb об'єкт трасування стека виключення 
<traceback object at 0x0000018A15310A80>. Метод __exit__ не повинен перехоплювати винятки, він потрібен лише для 
того, щоб правильно завершити контекст (закрити відкриті файли та з'єднання, повернути ресурси системі тощо).

Як бачимо механізм створення досить важкий. Тому Python дозволяє створювати менеджери контексту за допомогою 
генераторів і декоратора contextmanager з модуля contextlib. Це спрощує створення менеджерів контексту, особливо 
коли вони використовуються для одноразових або простих задач. """

from contextlib import contextmanager

@contextmanager
def my_context_manager():
    # Ініціалізація ресурсу
    print("Enter the block")
    try:
        yield  # Місце виконання блоку `with`
    except Exception as e:
        # Обробка виключень
        print(f"Error detected: {e}")
        # Можна ре-підняти виключення або вирішити його тут
        raise
    finally:
        # Звільнення ресурсу
        print("Exit the block")

# Використання
try:
    with my_context_manager():
        print("Inside the block")
        raise Exception("Something went wrong")
except Exception as e:
    print(f"Caught an exception: {e}")

# Виведення:
# Enter the block
# Inside the block
# Exit the block
# Error detected: Something went wrong
# Caught an exception: Something went wrong

""" Декоратор @contextmanager використовується для перетворення функції my_context_manager в менеджер контексту. 
Це дозволяє використовувати функцію у конструкції with ... as ..., спрощуючи створення менеджерів контексту без 
необхідності визначати клас з методами __enter__ та __exit__. Виведення цього коду повинно бути аналогічним.

Але, думаю, хотілось би більш реальний та практичний приклад, щоб до кінця зрозуміти механізм виконання менеджеру 
контексту. Створимо клас FileManager, який призначений для роботи з файлами та логування процесу відкриття та 
закриття файлу. """
class FileManager:
    def __init__(self, filename, mode='w', encoding='utf-8'):
        self.file = None
        self.opened = False
        self.filename = filename
        self.mode = mode
        self.encoding = encoding

    def __enter__(self):
        self.file = open(self.filename, self.mode, encoding=self.encoding)
        self.opened = True
        print("Відкриваємо файл", self.filename)
        return self.file

    def __exit__(self, exc_type, exc_val, exc_tb):
        print("Завершення блоку with")
        if self.opened:
            print("Закриваємо файл", self.filename)
            self.file.close()
        self.opened = False


if __name__ == '__main__':
    with FileManager('new_file.txt') as f:
        f.write('Hello world!\n')
        f.write('The end\n')

# Виведення:
# Відкриваємо файл new_file.txt
# Завершення блоку with
# Закриваємо файл new_file.txt

""" Конструктор класу FileManager ініціалізує екземпляр класу з певним ім'ям файлу filename, режимом 
відкриття файлу mode, та кодуванням encoding. За замовчуванням, режим встановлено на 'w' (запис), а 
кодування на 'utf-8' .

Метод __enter__ виконується на початку блоку with. Він відкриває файл з вказаними параметрами і зберігає 
відкритий файловий об'єкт у змінній self.file, а також встановлює прапорець self.opened в значення True. 
Ми виводимо сповіщення, що файл відкритий та повертаємо файловий об'єкт, що дозволяє використовувати його 
в контексті with. Фактично змінна f це self.file який повернув метод __enter__.

Метод __exit__ викликається при виході з блоку with, незалежно від того, виникла помилка чи ні при роботі 
з файлом. Ми перевіряємо прапорець self.opened і якщо він True то необхідно закрити файл, а далі 
встановлюємо прапорець в False.

Декоратор @contextmanager дозволяє нам створити контекстний менеджер за допомогою генератора, та 
спростити написання коду порівняно з класом FileManager, який використовує методи __enter__ та __exit__."""

from contextlib import contextmanager


@contextmanager
def file_manager(filename, mode='w', encoding='utf-8'):
    print("Відкриваємо файл", filename)
    file = open(filename, mode, encoding=encoding)
    try:
        yield file
    finally:
        print("Закриваємо файл", filename)
        file.close()
        print("Завершення блоку with")


if __name__ == '__main__':
    with file_manager('new_file.txt') as f:
        f.write('Hello world!\n')
        f.write('The end\n')

# Виведення:
# Відкриваємо файл new_file.txt
# Закриваємо файл new_file.txt
# Завершення блоку with

# Вміст файлу new_file.txt:
# Hello world!
# The end

""" У цьому коді функція file_manager визначена з декоратором @contextmanager. Вона відкриває файл і 
виводить повідомлення про відкриття, потім використовує yield для передачі файлового об'єкта у 
контекстний блок. Після виходу з блоку with код у блоку finally гарантує, що файл буде закритий, навіть 
якщо в процесі виконання в контекстному блоку виникне виключення, і виводить повідомлення про закриття 
файлу та завершення роботи з ним.

Цей підхід з використанням @contextmanager робить код більш лаконічним і читабельним, зберігаючи при 
цьому всі переваги контекстних менеджерів для управління ресурсами.

Створимо контекстний менеджер, який буде управляти відкриттям та закриттям файлу з додатковим логуванням. 
Наш контекстний менеджер managed_resource буде вимірювати час виконання операцій з файлом та логувати дії 
відкриття і закриття файлу разом з тривалістю їх виконання. """

from contextlib import contextmanager
from datetime import datetime


@contextmanager
def managed_resource(*args, **kwargs):
    log = ''
    timestamp = datetime.now().timestamp()
    msg = f'{timestamp:<20}|{args[0]:^15}| open \n'
    log += msg
    file_handler = open(*args, **kwargs)
    try:
        yield file_handler
    finally:
        diff = datetime.now().timestamp() - timestamp
        msg = f'{timestamp:<20}|{args[0]:^15}| closed {round(diff, 6):>15}s \n'
        log += msg
        file_handler.close()
        print(log)


with managed_resource('new_file.txt', 'r') as f:
    print(f.read())

""" Виведення:

Hello world!
The end

1707565076.245372   | new_file.txt  | open 
1707565076.245372   | new_file.txt  | closed        0.004001.



В процесі роботи, перш ніж файл буде відкритий, фіксується поточний час, що дозволяє згенерувати 
лог-повідомлення log про початок операції з файлом. Це повідомлення містить мітку часу, ім'я файлу та 
дію, яка виконується на даному етапі - відкриття файлу.

log = ''
timestamp = datetime.now().timestamp()
msg = f'{timestamp:<20}|{args[0]:^15}| open \n'
log += msg

Після цього файл відкривається з використанням переданих параметрів (ім'я файлу, режим відкриття, 
кодування), і файловий дескриптор повертається у блок with. Це дозволяє виконувати різні операції з 
файлом, наприклад, читання або запис. В нашому випадку ми просто читаємо рядки файлу.

file_handler = open(*args, **kwargs)
try:
    yield file_handler

При виході з блоку with виконується фінальна частина коду в рамках методу finally. Вона включає логування 
про закриття файлу, де також фіксується мітка часу і вказується тривалість виконання операцій з файлом. 
Файл закривається, а інформація про весь процес відкриття, використання та закриття файлу виводиться на 
екран.

finally:
        diff = datetime.now().timestamp() - timestamp
        msg = f'{timestamp:<20}|{args[0]:^15}| closed {round(diff, 6):>15}s \n'
        log += msg
        file_handler.close()
        print(log)

Таким чином, наш контекстний менеджер не тільки спрощує роботу з файлами, автоматизуючи процеси відкриття 
та закриття, але й забезпечує додаткову користь у вигляді детального логування процесів, замість 
використання звичайного open() . Це може бути досить корисно при діагностиці та аналізі продуктивності 
нашої програми. """